// ASMONET ON BOARD ESP32 CODE V3.0
#include <Arduino.h>
#include <SensirionI2CSen5x.h>
#include <Wire.h>
//#include <ADSWeather.h>
#include <HTTPClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include "SHTSensor.h"
#include "INA226.h"
#include "RTClib.h"
#include <ModbusMaster.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <SoftwareSerial.h>



#define HSPI_MISO   32
#define HSPI_MOSI   13
#define HSPI_SCLK   14
#define HSPI_SS     25



SPIClass hspi = SPIClass(HSPI);


// Your GPRS credentials (leave empty, if not needed)
const char apn[]      = "Internet"; // APN (example: internet.vodafone.pt) use https://wiki.apnchanger.org
const char gprsUser[] = ""; // GPRS User
const char gprsPass[] = ""; // GPRS Password

// SIM card PIN (leave empty, if not defined)
const char simPIN[]   = ""; 

// Server details
// The server variable can be just a domain name or it can have a subdomain. It depends on the service you are using
const char server[] = "solar.arelashesi.com"; // domain name: example.com, maker.ifttt.com, etc
const char resource[] = "/insertData2Cloud.php";         // resource path, for example: /post-data.php
const int  port = 80;                             // server port number

// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /post-data.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";

// TTGO T-Call pins
#define MODEM_RST            5
#define MODEM_PWKEY          4
#define MODEM_POWER_ON       23
#define MODEM_TX             27
#define MODEM_RX             26

// Relay Tick Counter
enum RelayStates {ON, OFF};
int relayTickCounter = 0;

enum RelayStates controlPrevRelayState = OFF;
enum RelayStates testPrevRelayState = OFF;
enum RelayStates controlRelayState = OFF;
enum RelayStates testRelayState = OFF;

// Set serial for AT commands (to SIM800 module)
#define SerialAT Serial1

// Configure TinyGSM library
#define TINY_GSM_MODEM_SIM800      // Modem is SIM800
#define TINY_GSM_RX_BUFFER   1024  // Set RX buffer to 1Kb

// Define the serial console for debug prints, if needed
//#define DUMP_AT_COMMANDS

#include <TinyGsmClient.h>

#ifdef DUMP_AT_COMMANDS
  #include <StreamDebugger.h>
  StreamDebugger debugger(SerialAT, Serial);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif


// TinyGSM Client for Internet connection
TinyGsmClient client(modem);



// LEDs
#define GREENLED 27
#define BLUELED 26
volatile int greenState = 0;

///......OLED Display......///

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

Adafruit_SH1106G display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

/// storing the last few log lines
#define OLED_LINE_CHARS 21
#define MAX_LINES 6
String logBuffer[MAX_LINES];

int devicesTotal = 0;
int devicesActive = 0;
String failedDevices = "";



////............Relay Module...............///
int controlPanelRelayPin = 18;
int testPanelRelayPin = 19;


////............DS18B20...............///

// Data wire is plugged TO GPIO 4
#define ONE_WIRE_BUS 33
#define TEMPERATURE_PRECISION 12

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// Number of temperature devices found
int numberOfDevices;

// We'll use this variable to store a found device address
DeviceAddress tempDeviceAddress;

// arrays to hold device addresses
DeviceAddress testPanelThermometer, controlPanelThermometer;

float temperatureValues[] = {0, 0, 0, 0, 0};

float testPanelTemperature = 0.0;
float controlPanelTemperature = 0.0;



////............WiFi Credentials...............//
//Replace with your network credentials
//const char* ssid     = "Air";
//const char* password = "8T06m98^";
const char* ssid     = "ARELAir";
const char* password = "WKHKYD?2023";

const String URL = "http://www.solar.arelashesi.com/insertData2Cloud.php?";


String userID = "0";
String deviceID = "xxv233";
float massOfDustOnPanel = 0.0;


bool GSMConnectionStatus = false;
String localData = "";
bool localDataAvailable = false;



/// -------- RTC Module ----------///
RTC_DS3231 rtc;

char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

String localDateTime = "";
String timeHour = "";
int timeHourInt = 0;
int timeMinInt = 0;

String timeMinute = "";
String timeSecond = "";
String dateYear = "";
String dateMonth = "";
String dateDay = "";
String dateSend = "";
String timeSend = "";

////..........SD Card............//
// Timer variables
String dataMessage;
unsigned long epochTime = 0;
bool checkSD(bool verbose = true);



////..........SHT35............//

SHTSensor sht;
float shtHumidity = 0;
float shtTemperature = 0;
// To use a specific sensor instead of probing the bus use this command:
// SHTSensor sht(SHTSensor::SHT3X);



////..........INA226............//


float inachargeControlCurrentControl = 0.0;//Off
float inachargeControlCurrentTest = 0.0;//Off

float inachargeControlVoltageControl = 0.0;//Off
float inachargeControlVoltageTest = 0.0;//Off

float inachargeControlPowerControl = 0.0;//Off
float inachargeControlPowerTest = 0.0;//Off


float panelPowerControl = 0;
float panelPowerTest = 0;

float panelCurrentControl = 0;
float panelCurrentTest = 0;

float inapanelVoltageControl = 0;//Off
float inapanelVoltageTest = 0;//Off

float efficiencyControl = 0;
float efficiencyTest = 0;

INA226 controlPanel(0x40);
INA226 controlChargeController(0x41);
INA226 testPanel(0x43);
INA226 testChargeController(0x45);


////-----Modbus Charge Controller Power read--------////


// Modbus Instance
ModbusMaster node;

// RS485 Communication Pins
#define RS485_RX_SLAVE_1 15 // RX pin for Slave 1
#define RS485_TX_SLAVE_1 2  // TX pin for Slave 1
#define RS485_RX_SLAVE_2 2  // RX pin for Slave 2
#define RS485_TX_SLAVE_2 15 // TX pin for Slave 2

// Define the HardwareSerial port (e.g., Serial2 for ESP32)
HardwareSerial RS485(2); // Use UART2 for RS485 communication

// Known Register Addresses
#define BATTERY_CHARGE_PERCENT 0x101
#define BATTERY_VOLTAGE 0x102
#define CHARGING_CURRENT 0x103
#define BATTERY_POWER 0x104
#define PANEL_VOLTAGE 0x109
#define LOAD_VOLTAGE 0x106
#define LOAD_CURRENT 0x107
#define LOAD_POWER 0x108

// Variables for Test and Control Data
float panelVoltageTest = 0;//In use
float chargeControlCurrentTest = 0;//In use
float chargeControlPowerTest = 0;//In use (Calculated)
float chargeControlVoltageTest = 0; //In use
float batteryChargePercentTest = 0;//In use
float batteryPowerTest = 0;// Pre-calculated value
float loadVoltageTest = 0;
float loadCurrentTest = 0;
float loadPowerTest = 0;
float calcIndexTest = 0;
float instIndexTest = 0;

float panelVoltageControl = 0;//In use
float chargeControlCurrentControl = 0;//In use
float chargeControlPowerControl = 0;//In use (Calculated)
float chargeControlVoltageControl = 0;//In use
float batteryChargePercentControl = 0;//In use
float batteryPowerControl = 0;// Pre-calculated value
float loadVoltageControl = 0;
float loadCurrentControl = 0;
float loadPowerControl = 0;
float calcIndexControl =0;
float instIndexControl = 0;

////.............PM Sensor................////

// The used commands use up to 48 bytes. On some Arduino's the default buffer
// space is not large enough
#define MAXBUF_REQUIREMENT 48

#if (defined(I2C_BUFFER_LENGTH) &&                 \
     (I2C_BUFFER_LENGTH >= MAXBUF_REQUIREMENT)) || \
    (defined(BUFFER_LENGTH) && BUFFER_LENGTH >= MAXBUF_REQUIREMENT)
#define USE_PRODUCT_INFO
#endif

SensirionI2CSen5x sen5x;

float massConcentrationPm1p0;
float massConcentrationPm2p5;
float massConcentrationPm4p0;
float massConcentrationPm10p0;
float ambientHumidity;
float ambientTemperature;
float vocIndex;
float noxIndex;


// SHTSensor sht(SHTSensor::SHT3X);





///...........Deep Sleep..................//
//#define uS_TO_S_FACTOR 1000000ULL  /* Conversion factor for micro seconds to seconds */
//#define TIME_TO_SLEEP  10        /* Time ESP32 will go to sleep (in seconds) */

unsigned long previousRuntime = 0; 
unsigned long previousLocalDataRuntime = 0; 

unsigned long cpmill = 0;
unsigned long ccpmill = 0;
unsigned long tpmill = 0;
unsigned long ttpmill = 0;


// --- Datalogger Serial (CR1000X) ---
EspSoftwareSerial::UART DataSerial;   // create a software UART object
#define DATALOGGER_RX 35              // RX pin from CR1000X TX
#define DATALOGGER_BAUD 9600      // must match SerialOpen(ComC7,...) on logger

float irradiance = 0.0;       // Parsed irradiance value (W/m²)
String irradianceTimestamp = "";  // Parsed timestamp from datalogger

////..........Weather Station Placeholder values........//

unsigned long nextCalc;
unsigned long timer;


float rainAmount;
long windDirection;
int windGust;
float windSpeedD;







void setup() {

    Serial.begin(9600);
    while (!Serial) {
        delay(100);
    }

    pinMode(BLUELED, OUTPUT);
    pinMode(GREENLED, OUTPUT);

    pinMode(controlPanelRelayPin, OUTPUT);
    pinMode(testPanelRelayPin, OUTPUT);
    
    digitalWrite(BLUELED, HIGH);
    digitalWrite(GREENLED, LOW);

    digitalWrite(controlPanelRelayPin, HIGH);
    digitalWrite(testPanelRelayPin, HIGH);

    Wire.begin();


    //-------------OLED--------//

  // --- OLED Init ---
    if (!display.begin(0x3C, true)) {
      Serial.println("OLED init failed");
    } else {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SH110X_WHITE);
      display.setCursor(0,0);
      display.println("OLED Ready");
      display.display();
      delay(1000);
    }

    ///..........PM SENSOR.........////

    sen5x.begin(Wire);

    bool pmOk = true;   // good until a step fails
    uint16_t error;
    char errorMessage[256];

    error = sen5x.deviceReset();
    if (error) {
        Serial.print("Error trying to execute deviceReset(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
        logToOLED("PM reset error");
        pmOk = false;
    }

    // Print SEN55 module information if i2c buffers are large enough
    #ifdef USE_PRODUCT_INFO
        printSerialNumber();
        printModuleVersions();
    #endif

    // set a temperature offset in degrees celsius
    // Note: supported by SEN54 and SEN55 sensors
    // By default, the temperature and humidity outputs from the sensor
    // are compensated for the modules self-heating. If the module is
    // designed into a device, the temperature compensation might need
    // to be adapted to incorporate the change in thermal coupling and
    // self-heating of other device components.
    //
    // A guide to achieve optimal performance, including references
    // to mechanical design-in examples can be found in the app note
    // “SEN5x – Temperature Compensation Instruction” at www.sensirion.com.
    // Please refer to those application notes for further information
    // on the advanced compensation settings used
    // in setTemperatureOffsetParameters, setWarmStartParameter and
    // setRhtAccelerationMode.
    //
    // Adjust tempOffset to account for additional temperature offsets
    // exceeding the SEN module's self heating.
    float tempOffset = 0.0;
    error = sen5x.setTemperatureOffsetSimple(tempOffset);
    if (error) {
        Serial.print("Error trying to execute setTemperatureOffsetSimple(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
        logToOLED("PM Temp Offset error");
        pmOk = false;
    } else {
        Serial.print("Temperature Offset set to ");
        Serial.print(tempOffset);
        Serial.println(" deg. Celsius (SEN54/SEN55 only");
        logToOLED("PM Temp offset OK");
        logToOLED(String(tempOffset));
    }

    // Start Measurement
    error = sen5x.startMeasurement();
    if (error) {
        Serial.print("Error trying to execute startMeasurement(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
        logToOLED("PM Start Measurement Error");
        pmOk = false;
    } else{
      logToOLED("PM Measurement Started");
    }

    devicesTotal++;
    if (pmOk) {
        devicesActive++;
    } else {
        failedDevices += "PM Sensor, ";
    }


    ////..........INA226............//
    // Initialize the INA226.
    
    bool inaCtrlPanelOk       = controlPanel.begin();
    bool inaCtrlChargeOk      = controlChargeController.begin();
    bool inaTestPanelOk       = testPanel.begin();
    bool inaTestChargeOk      = testChargeController.begin();

    if (!inaCtrlPanelOk) {
      Serial.println("controlPanel could not connect. Fix and Reboot");
      logToOLED("INA226 controlPanel Error");
      failedDevices += "INA226 controlPanel, ";
    }
    devicesTotal++;
    if (inaCtrlPanelOk) devicesActive++;

    if (!inaCtrlChargeOk) {
      Serial.println("controlChargeController could not connect. Fix and Reboot");
      logToOLED("INA226 controlChargeController Error");
      failedDevices += "INA226 controlChargeController, ";
    }
    devicesTotal++;
    if (inaCtrlChargeOk) devicesActive++;

    if (!inaTestPanelOk) {
      Serial.println("testPanel could not connect. Fix and Reboot");
      logToOLED("INA226 testPanel Error");
      failedDevices += "INA226 testPanel, ";
    }
    devicesTotal++;
    if (inaTestPanelOk) devicesActive++;

    if (!inaTestChargeOk) {
      Serial.println("testChargeController could not connect. Fix and Reboot");
      logToOLED("INA226 testChargeController Error");
      failedDevices += "INA226 testChargeController, ";
    }
    devicesTotal++;
    if (inaTestChargeOk) devicesActive++;

    
    controlPanel.setMaxCurrentShunt(1, 0.002);
    controlChargeController.setMaxCurrentShunt(1, 0.002);
    testPanel.setMaxCurrentShunt(1, 0.002);
    testChargeController.setMaxCurrentShunt(1, 0.002);







    ///..........SHT35 Initialization..........//
    bool shtOk = sht.init();
    if (shtOk) {
        Serial.print("init(): success\n");
        logToOLED("SHT35 init success");
        devicesActive++;
    } else {
        Serial.print("init(): failed\n");
        logToOLED("SHT35 init failed");
        failedDevices += "SHT35, ";
    }
    devicesTotal++;
    if (shtOk) {
        sht.setAccuracy(SHTSensor::SHT_ACCURACY_MEDIUM); // only supported by SHT3x
    }



    //----------------TEMP PROBES--------------------//
    // Start up the library
    sensors.begin();

    // Grab a count of devices on the wire
    numberOfDevices = sensors.getDeviceCount();

    devicesTotal++;
    if (numberOfDevices > 0) {
        devicesActive++;
    } else {
        failedDevices += "DS18B20, ";
    }


    // method 1: by index
    if (!sensors.getAddress(controlPanelThermometer, 0)) {
        Serial.println("Unable to find address for Device 0");
        logToOLED("DS18B20 Dev0 not found");
    }
    if (!sensors.getAddress(testPanelThermometer, 1)) {
        Serial.println("Unable to find address for Device 1");
        logToOLED("DS18B20 Dev1 not found");
    }

    // show the addresses we found on the bus
    Serial.print("Device 0 Address: ");
    printAddress(controlPanelThermometer);
    Serial.println();
    logToOLED("DS18B20 Dev0 Addr OK");

    Serial.print("Device 1 Address: ");
    printAddress(testPanelThermometer);
    Serial.println();
    logToOLED("DS18B20 Dev1 Addr OK");

    // set the resolution to 9 bit per device
    sensors.setResolution(controlPanelThermometer, TEMPERATURE_PRECISION);
    sensors.setResolution(testPanelThermometer, TEMPERATURE_PRECISION);

    Serial.print("Device 0 Resolution: ");
    Serial.print(sensors.getResolution(controlPanelThermometer), DEC);
    Serial.println();
    logToOLED("DS18B20 Dev0 Res set");

    Serial.print("Device 1 Resolution: ");
    Serial.print(sensors.getResolution(testPanelThermometer), DEC);
    Serial.println();
    logToOLED("DS18B20 Dev1 Res set");

    // locate devices on the bus
    Serial.print("Locating devices...");
    Serial.print("Found ");
    Serial.print(numberOfDevices, DEC);
    Serial.println(" devices.");
    logToOLED("Found " + String(numberOfDevices) + " DS18B20");



    ////..........SD Card............//

    setupSDCard();
    checkSD();   // verify SD is working after initial mount

    devicesTotal++;
    if (!SD.begin(HSPI_SS, hspi)) {
       failedDevices += "SD Card, ";
    } else {
       devicesActive++;
    }



    
    // Create a file on the SD card and write the data labels
    File file = SD.open("/data.txt");
    if(!file) {
      Serial.println("File doesn't exist");
      logToOLED("SD: data.txt missing");
      Serial.println("Creating file...");
      logToOLED("SD: Creating data.txt");
      writeFile(SD, "/data.txt", "Epoch Time, Device_id, Temperature, Humidity, Panel1Current, Panel1Voltage, Panel1Power, Panel2Current, Panel2Voltage, Panel2Power, Panel3Current, Panel3Voltage, Panel3Power, Panel4Current, Panel4Voltage, Panel4Power, PM_1, PM_2_5, PM_4, PM_10, VOC, NOx \r\n");
    }
    else {
      Serial.println("File already exists");  
      logToOLED("SD: data.txt exists");
    }
    file.close();


    // If the localdata.txt file doesn't exist
    // Create a file on the SD card and write the data labels
    File fileLocalData = SD.open("/localdata.txt");
    if(!fileLocalData) {
      Serial.println("File doesn't exist");
      logToOLED("SD: localdata.txt missing");
      Serial.println("Creating file...");
      logToOLED("SD: Creating localdata.txt");
      writeFile(SD, "/localdata.txt", "Epoch Time, Device_id, Temperature, Humidity, Panel1Current, Panel1Voltage, Panel1Power, Panel2Current, Panel2Voltage, Panel2Power, Panel3Current, Panel3Voltage, Panel3Power, Panel4Current, Panel4Voltage, Panel4Power, PM_1, PM_2_5, PM_4, PM_10, VOC, NOx \r\n");
    }
    else {
      Serial.println("File already exists");  
      logToOLED("SD: localdata.txt exists");
    }
    fileLocalData.close();



    ////..........RTC Module............//

    bool rtcOk = rtc.begin();


    if (!rtcOk) {
      Serial.println("Couldn't find RTC");
      logToOLED("RTC not found");
      failedDevices += "RTC, ";
      Serial.flush();
      // while (1) delay(10);
    }
    devicesTotal++;
    if (rtcOk) devicesActive++;

    if (rtc.lostPower()) {
      Serial.println("RTC lost power, let's set the time!");
      logToOLED("RTC lost power");
      // When time needs to be set on a new device, or after a power loss, the
      // following line sets the RTC to the date & time this sketch was compiled
    //  rtc.adjust(DateTime(F(DATE), F(TIME)));
      // This line sets the RTC with an explicit date & time, for example to set
      // January 21, 2014 at 3am you would call:
      rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
}



    ////..................ModBus......................////
    // Initialize RS485 Communication
    Serial.begin(9600); // Debug Serial Monitor

    // --- Slave 1: Test Charge Controller ---
    RS485.begin(9600, SERIAL_8N1, RS485_RX_SLAVE_1, RS485_TX_SLAVE_1);
    node.begin(1, RS485);

    devicesTotal++;
    uint8_t mbResult = node.readHoldingRegisters(PANEL_VOLTAGE, 1);
    if (mbResult == node.ku8MBSuccess) {
        devicesActive++;
        Serial.println("Modbus TestChrg (Slave1) OK");
        logToOLED("Modbus TestChrg OK");
    } else {
        Serial.println("Modbus TestChrg (Slave1) Error");
        logToOLED("Modbus TestChrg Error");
        failedDevices += "Modbus TestChrg, ";
    }

    // --- Slave 2: Control Charge Controller ---
    RS485.end();
    delay(50);
    RS485.begin(9600, SERIAL_8N1, RS485_RX_SLAVE_2, RS485_TX_SLAVE_2);
    node.begin(2, RS485);

    devicesTotal++;
    mbResult = node.readHoldingRegisters(PANEL_VOLTAGE, 1);
    if (mbResult == node.ku8MBSuccess) {
        devicesActive++;
        Serial.println("Modbus CtrlChrg (Slave2) OK");
        logToOLED("Modbus CtrlChrg OK");
    } else {
        Serial.println("Modbus CtrlChrg (Slave2) Error");
        logToOLED("Modbus CtrlChrg Error");
        failedDevices += "Modbus CtrlChrg, ";
    }

    // Leave RS485 clean
    RS485.end();

    checkSD(false);




    /// ---- Datalogger ---- ///
    // --- Initialize SoftwareSerial for CR1000X ---
    DataSerial.begin(DATALOGGER_BAUD, EspSoftwareSerial::SWSERIAL_8N1, DATALOGGER_RX, -1, false, 256);
    DataSerial.enableRx(true);  // make sure receiver is active

    devicesTotal++;
    bool dataloggerOk = false;

    // Clear any stale data first
    while (DataSerial.available()) DataSerial.read();

    // Wait briefly for a new frame (up to ~3 seconds)
    unsigned long startCheck = millis();
    String line = "";
    while (millis() - startCheck < 3000) {
        if (DataSerial.available()) {
            line = DataSerial.readStringUntil('\n');
            line.trim();
            if (line.length() > 0) {
                dataloggerOk = true;
                break;
            }
        }
    }

    if (dataloggerOk) {
        devicesActive++;
        Serial.println("Datalogger Active");
        logToOLED("Datalogger Active");
    } else {
        Serial.println("Datalogger Error");
        logToOLED("Datalogger Error");
        failedDevices += "Datalogger, ";
    }

    checkSD(false);




    ///..........GSM Connection..........//

    // Set modem reset, enable, power pins
    pinMode(MODEM_PWKEY, OUTPUT);
    pinMode(MODEM_RST, OUTPUT);
    pinMode(MODEM_POWER_ON, OUTPUT);
    digitalWrite(MODEM_PWKEY, LOW);
    digitalWrite(MODEM_RST, HIGH);
    digitalWrite(MODEM_POWER_ON, HIGH);

    delay(3000);

    // Set GSM module baud rate and UART pins
    SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);
    //SerialAT.begin(9600, SERIAL_8N1, MODEM_RX, MODEM_TX);
    delay(3000);

    // Restart SIM800 module, it takes quite some time
    // To skip it, call init() instead of restart()
    Serial.println("Initializing modem...");
    logToOLED("Initializing modem...");
    // modem.init();
    GSMConnectionStatus = modem.restart();

    // use modem.init() if you don't need the complete restart

    // --- Confirm modem response ---
    devicesTotal++;
    if (GSMConnectionStatus) {
      devicesActive++;
      Serial.println("Modem responded OK");
      logToOLED("Modem OK");
    } else {
      Serial.println("Modem not responding, retrying with init()...");
      logToOLED("Modem retrying init...");
      GSMConnectionStatus = modem.init();
      delay(4000);
      if (GSMConnectionStatus) {
        devicesActive++;
        Serial.println("Modem recovered using init()");
        logToOLED("Modem recovered");
      } else {
        Serial.println("Modem failed to start, check power/wiring!");
        logToOLED("Modem failed");
        failedDevices += "Modem, ";
      }
    }

    checkSD(false);
    delay(10000);

    // Unlock your SIM card with a PIN if needed
    if (strlen(simPIN) && modem.getSimStatus() != 3 ) {
      modem.simUnlock(simPIN);
    }

    // Turn off network status lights to reduce current consumption
    turnOffNetlight();
    checkSD(false);

    ///..........Control LED Indicators..........//
    onBlue();
    onGreen();

    ///..........Transmit Local Data To Server..........//
    checkAndSendLocalDataToServer();

    ///...............Deep Sleep............//
    //    esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);
    //    Serial.println("Setup ESP32 to sleep for every " + String(TIME_TO_SLEEP) + " Seconds");



    //int ccount = 0;



    String summary = "Devices: " + String(devicesActive) + "/" + String(devicesTotal);
    Serial.println(summary);
    logToOLED(summary);

    if (failedDevices.length() > 0) {
        // remove trailing comma + space
        failedDevices.remove(failedDevices.length() - 2);
        Serial.println("Failed: " + failedDevices);
        logToOLED("Failed: " + failedDevices);
    } else {
        Serial.println("All devices OK");
        logToOLED("All devices OK");
    }





}

void loop() {

  ///..........Control LED Indicators..........//
  onBlue();
  onGreen();

  ///..........Reconnect Wi-Fi..........//
  // reconnectWiFi();

  ///..........Transmit Local Data To Server..........//
  if(millis() - previousLocalDataRuntime >= 600000){
    checkAndSendLocalDataToServer();
    previousLocalDataRuntime = millis();
  }

  ///..........INA226............//
  readINA226SensorData();

  /// ...... Modbus...........///
  readModbusAndCompute();

  ///..........PM Sensor............//
  readPMSensorData();

  ///..........SHT35..........//
  readSHT35Sensor();

  ///..........DS18B20..........//
  readTemperatureProbes();


  ///...........RTC.............//
  // setTimezone("GMT0");
  getTimeAndDate();
 
///......Datalogger...........///
  readFromDatalogger();


  /*
  // Reset rainfall amount and relay tick counter at midnight/new day
  if(timeHourInt == 0 && timeMinInt < 3){
    ws1.resetRain();
    relayTickCounter = 0;
  }

  ///.......... Old Weather Station..........//  
  readWeatherStationData();
  */

  ///..........Prepare URL for POST Request..........//
  String requestData = "user_id=" + userID + "&device_id="+ deviceID + "&massOfDust=" + String(massOfDustOnPanel) + "&tempOfPanelControl=" + String(controlPanelTemperature)+ "&tempOfPanelTest=" + String(testPanelTemperature) + "&ambientTemp=" + String(shtTemperature) + "&humidity=" + String(shtHumidity) + 
                    "&panelCurrentControl=" + String(panelCurrentControl) + "&panelCurrentTest=" + String(panelCurrentTest) + "&chargeControlCurrentControl=" + 
                    String(chargeControlCurrentControl) + "&chargeControlCurrentTest=" + String(chargeControlCurrentTest) + "&panelVoltageControl=" + String(panelVoltageControl) + "&panelVoltageTest=" + 
                    String(panelVoltageTest) + "&chargeControlVoltageControl=" + String(chargeControlVoltageControl) + "&chargeControlVoltageTest=" + String(chargeControlVoltageTest) + "&massConcentrationPm1p0=" + String(massConcentrationPm1p0) + 
                    "&massConcentrationPm2p5=" + String(massConcentrationPm2p5) + "&massConcentrationPm4p0=" + String(massConcentrationPm4p0) + "&massConcentrationPm10p0=" + String(massConcentrationPm10p0) + "&ambientHumidityPM=" + String(ambientHumidity) + "&ambientTemperaturePM=" + String(ambientTemperature)+ "&windDirection=" + String(windDirection) + "&windSpeed=" + String(windSpeedD) + "&amountOfRainfall=" + String(rainAmount) + 
                    "&panelPowerControl=" + String(panelPowerControl) + "&panelPowerTest=" + String(panelPowerTest) + "&chargeControlPowerControl=" + String(chargeControlPowerControl) + "&chargeControlPowerTest=" + String(chargeControlPowerTest) + "&irradiance=" + String(irradiance) + "&vocIndex=" + String(vocIndex) + "&noxIndex=" + String(noxIndex) + "&deviceLocalTime=" + timeSend + "&deviceLocalDate=" + dateSend + "&relayTickCounter=" + String(relayTickCounter) + 
                    "&batteryChargePercentTest=" + String(batteryChargePercentTest) + "&batteryChargePercentControl=" + String(batteryChargePercentControl)+ 
                    "&calcIndexControl=" + String(calcIndexControl) + "&instIndexControl=" + String(instIndexControl) + "&efficiencyControl=" + String(efficiencyControl)+ 
                    "&calcIndexTest=" + String(calcIndexTest) + "&instIndexTest=" + String(instIndexTest) + "&efficiencyTest=" + String(efficiencyTest)+ "";

  Serial.println("Data being posted:");
  Serial.println(requestData);         


  if (previousRuntime == 0 || millis() - previousRuntime > 180000)
  {
    if (GSMConnectionStatus)
    {
      Serial.println(requestData);
      //Check if upload was successful else store data locally
      if(!sendHTTPRequestViaGSM(requestData)){
        requestData = requestData + "|";
        appendFile(SD,"/localdata.txt",requestData.c_str());
      }
    }else
    {
      requestData = requestData + "|";
      appendFile(SD,"/localdata.txt",requestData.c_str());
    }


    ///...........Save to SD Card.............//
    //Concatenate all info separated by commas
    dataMessage = String(epochTime) + "," + String(userID) + "," + String(deviceID) + "," + String(controlPanelTemperature) + "," + String(testPanelTemperature) + "," + String(shtTemperature) + "," + String(shtHumidity) +
                "," + String(panelCurrentControl) + "," + String(chargeControlCurrentControl) + "," + String(panelCurrentTest) +  "," + String(chargeControlCurrentTest) + "," + String(inachargeControlCurrentControl) + "," + String(inachargeControlCurrentTest) + "," + String(inapanelVoltageControl) + 
                "," + String(panelVoltageControl) +  "," + String(inapanelVoltageTest) + "," + String(panelVoltageTest) + ","+ String(inachargeControlVoltageControl) + "," + String(chargeControlVoltageControl) + "," + String(inachargeControlVoltageTest) + "," + String(chargeControlVoltageTest) + ","+ String(massConcentrationPm1p0) + 
                "," + String(massConcentrationPm2p5) + "," + String(massConcentrationPm4p0) + "," + String(massConcentrationPm10p0) + "," + String(ambientHumidity) + "," + String(ambientTemperature) + "," + String(windDirection) + "," + String(windSpeedD) + "," + String(rainAmount) + 
                "," + String(panelPowerControl) + "," + String(chargeControlPowerControl) + ","+ String(panelPowerTest) + "," + String(chargeControlPowerTest) + ","+ String(inachargeControlPowerControl) + "," + String(inachargeControlPowerTest) + "," + String(irradiance) + "," + String(relayTickCounter) + "," + String(timeSend) + "," + String(dateSend) + "," + String(vocIndex) + "," + String(noxIndex) + "\r\n";
    Serial.print("Saving data: ");
    Serial.println(dataMessage);

    //Append the data to file
    appendFile(SD, "/data.txt", dataMessage.c_str());

    ///..........Transmit Local Data To Server..........//
    checkAndSendLocalDataToServer();


    previousRuntime = millis();
  }

  // Update relay state
  updateRelayState();

  ///...........Control Relays.............//
  // loadControl();

  //dischargeLoads(chargeControlVoltageTest, chargeControlVoltageControl);
  dischargeLoads(batteryChargePercentTest,batteryChargePercentControl);


  // count relay tick
  countRelayTick();
}


void onGreen() {
  if (GSMConnectionStatus)
  {
    digitalWrite(GREENLED, HIGH);
  } else {
    digitalWrite(GREENLED, LOW);
  }
}

void onBlue() {
  if (!GSMConnectionStatus)
  {
    digitalWrite(BLUELED, HIGH);
  } else {
    digitalWrite(BLUELED, LOW);
  }
}

bool sendHTTPRequestViaGSM(String httpRequestData){
  Serial.print("Connecting to APN: ");
  Serial.print(apn);
  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
    Serial.println(" fail");
  }
  else {
    Serial.println(" OK");
    
    Serial.print("Connecting to ");
    Serial.print(server);
    if (!client.connect(server, port)) {
      Serial.println(" fail");
      return false;
    }
    else {
      Serial.println(" OK");
    
      // Making an HTTP POST request
      Serial.println("Performing HTTP POST request...");
      client.print(String("POST ") + resource + " HTTP/1.1\r\n");
      client.print(String("Host: ") + server + "\r\n");
      client.println("Connection: close");
      client.println("Content-Type: application/x-www-form-urlencoded");
      client.print("Content-Length: ");
      client.println(httpRequestData.length());
      client.println();
      client.println(httpRequestData);

      unsigned long timeout = millis();
      while (client.connected() && millis() - timeout < 10000L) {
        // Print available data (HTTP response from server)
        while (client.available()) {
          char c = client.read();
          Serial.print(c);
          timeout = millis();
        }
      }
      Serial.println();
      return true;
    }
  }
}

void updateRelayState(){
  // set current state to the previous state before relay control.
  controlPrevRelayState = controlRelayState;
  testPrevRelayState = testRelayState;
}

void countRelayTick(){
  // count relay tick if previous state is different from current
  if(controlPrevRelayState != controlRelayState){
    relayTickCounter++;
  }
  if(testPrevRelayState != testRelayState){
    relayTickCounter++;
  }
}

bool sendLocalData(String &localDataToSend){

  int lengthOfData = localDataToSend.length();

  int numberOfDataRows = (lengthOfData/70)+2;
  // Serial.println("Length of Data");
  // Serial.println(numberOfDataRows);
  String dataToSend = "";
  // Serial.println(numberOfDataRows);
  // Serial.println(localDataToSend);

  // count number of | in local data
  int StringCount = count(localDataToSend, '|');

    // Split the string into substrings

  int dataCounter = 0;

  // while there is still data available for transmission
  while (localDataToSend.length() > 0)
  {
    dataCounter = dataCounter+1;
    int index = localDataToSend.indexOf('|');
    if (index == -1) // No | found
    {
      // if there is no | at the end of data (last data to be transmitted) then assign the full string to be transmitted
      dataToSend = localDataToSend;
      break;
    }
    else
    {
      // split string up to the first | for transmission 
      dataToSend = localDataToSend.substring(0, index);
      // start new data string from the first | to the end of the string
      localDataToSend = localDataToSend.substring(index+1);
    }
    // Serial.println("Lengtta");
    Serial.print("Sending local data.................(");
    Serial.print(dataCounter);
    Serial.print("/");
    Serial.print(StringCount);
    Serial.println(")");
    // Serial.println(dataToSend);
    if(!sendHTTPRequestViaGSM(dataToSend)){
      // Return false if tranmission fails and regenerate the last transmit data string state
      localDataToSend = localDataToSend + dataToSend + "|";
      // Serial.println(localDataToSend);
      return false;
    }

  }

  // for (int i = 0; i < StringCount; i++)
  // {
    
  //   // Serial.println(dataRow);
  // }
  return true;
}

int count(String s, char c)
{
  // Count variable
  int res = 0;

  for (int i=0;i<s.length();i++)

    // checking character in string
    if (s[i] == c)
      res++;

  return res;
}

void readTemperatureProbes(){

  float temptemp = 0.0;
  Serial.println();
  Serial.println("------DS18B20------");

  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures();
  Serial.println("DONE");

  // print the device information
  temptemp = getTemperature(controlPanelThermometer);
  if(temptemp > 1.0){
    controlPanelTemperature = temptemp;
  }

  temptemp = getTemperature(testPanelThermometer);
  if(temptemp > 1.0){
    testPanelTemperature = temptemp;
  }
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    // zero pad the address if necessary
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

// function to print and return the temperature for a panel
float getTemperature(DeviceAddress deviceAddress)
{
  float tempC = sensors.getTempC(deviceAddress);
  if(tempC == DEVICE_DISCONNECTED_C) 
  {
    Serial.println("Error: Could not read temperature data");
    return 0;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.print(DallasTemperature::toFahrenheit(tempC));
  return tempC;
}

void getTimeAndDate(){
  Serial.println("------TIME------");

  DateTime now = rtc.now();
  unsigned long epochTime = now.unixtime();

  dateYear = String(now.year());
  dateMonth = String(now.month());
  dateDay = String(now.day());
  timeHour = String(now.hour());
  timeHourInt = now.hour();
  timeMinute = String(now.minute());
  timeSecond = String(now.second());

  dateSend = dateYear + "-" + dateMonth + "-" + dateDay;
  timeSend = timeHour + ":" + timeMinute + ":" + timeSecond;

  Serial.print(dateSend);
  Serial.print("  ");
  Serial.println(timeSend);

}

void loadControl(){
  if (timeHourInt >= 20 || timeHourInt < 5)
  {
    digitalWrite(controlPanelRelayPin, HIGH);
    digitalWrite(testPanelRelayPin, HIGH);
    Serial.println("Relays Off >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
  }else{
    digitalWrite(controlPanelRelayPin, LOW);
    digitalWrite(testPanelRelayPin, LOW);
    Serial.println("Relays On <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
  }
  
}

void controlLoadRelayStatus(String on_off_status){
  if(on_off_status == "OFF"){
    digitalWrite(controlPanelRelayPin, LOW);
    controlRelayState = OFF;
  }
  if(on_off_status == "ON"){
    digitalWrite(controlPanelRelayPin, HIGH);
    controlRelayState = ON;
  }
}

void testLoadRelayStatus(String on_off_status){
  if(on_off_status == "OFF"){
    digitalWrite(testPanelRelayPin, LOW);
    testRelayState = OFF;
  }
  if(on_off_status == "ON"){
    digitalWrite(testPanelRelayPin, HIGH);
    testRelayState = ON;
  }
}

void printModuleVersions() {
    uint16_t error;
    char errorMessage[256];

    unsigned char productName[32];
    uint8_t productNameSize = 32;

    error = sen5x.getProductName(productName, productNameSize);

    if (error) {
        Serial.print("Error trying to execute getProductName(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
    } else {
        Serial.print("ProductName:");
        Serial.println((char*)productName);
    }

    uint8_t firmwareMajor;
    uint8_t firmwareMinor;
    bool firmwareDebug;
    uint8_t hardwareMajor;
    uint8_t hardwareMinor;
    uint8_t protocolMajor;
    uint8_t protocolMinor;

    error = sen5x.getVersion(firmwareMajor, firmwareMinor, firmwareDebug,
                             hardwareMajor, hardwareMinor, protocolMajor,
                             protocolMinor);
    if (error) {
        Serial.print("Error trying to execute getVersion(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
    } else {
      Serial.print("Firmware: ");
      Serial.print(firmwareMajor);
      Serial.print(".");
      Serial.print(firmwareMinor);
      Serial.print(", ");

      Serial.print("Hardware: ");
      Serial.print(hardwareMajor);
      Serial.print(".");
      Serial.println(hardwareMinor);
    }
}

void printSerialNumber() {
    uint16_t error;
    char errorMessage[256];
    unsigned char serialNumber[32];
    uint8_t serialNumberSize = 32;

    error = sen5x.getSerialNumber(serialNumber, serialNumberSize);
    if (error) {
        Serial.print("Error trying to execute getSerialNumber(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
    } else {
        Serial.print("SerialNumber:");
        Serial.println((char*)serialNumber);
    }
}

void checkAndSendLocalDataToServer(){
  ///..........Setup Local Data Storage..........//
   /*  if(!SPIFFS.begin()){
        Serial.println("Card Mount Failed");
        return;
    } */

    localData = readFile(SD, "/localdata.txt");
    
    //check if there is data available for transmission
    if(localData.length()>10){
      localDataAvailable = true;
      Serial.println("Local data available for transmission.");
      
      //If data is available check for wifi connection
      if (GSMConnectionStatus)
      {

        // if GSM is connected send data to server
        if(sendLocalData(localData)){
          // if sending is successful, clear local data
          SD.remove("/localdata.txt");
          writeFile(SD,"/localdata.txt","");
          localDataAvailable = false;
          Serial.println("Local Data Transmitted Successfully.");
        }else
        {
          // if sending is unsuccessful update local data
          //appendFile(SD,"/localdata.txt",localData.c_str());
          Serial.print("Local Data Transmission Failed.");
        }
        
      }else
      {
        Serial.println("No Wi-Fi Connection -- Local Data Could not be Transmitted.");
      }
      
      // sendLocalData(localData);
      
    }else
    {
      localDataAvailable = false;
      Serial.println("No local data available for transmission.");

    }
}

void readPMSensorData(){
    Serial.print("PM Sensor\n");
    uint16_t error;
    char errorMessage[256];

    delay(1000);

    error = sen5x.readMeasuredValues(
        massConcentrationPm1p0, massConcentrationPm2p5, massConcentrationPm4p0,
        massConcentrationPm10p0, ambientHumidity, ambientTemperature, vocIndex,
        noxIndex);

    if (error) {
        Serial.print("Error trying to execute readMeasuredValues(): ");
        errorToString(error, errorMessage, 256);
        Serial.println(errorMessage);
        

    } else {
        Serial.print("MassConcentrationPm1p0:");
        Serial.print(massConcentrationPm1p0);
        Serial.print("\t");
        Serial.print("MassConcentrationPm2p5:");
        Serial.print(massConcentrationPm2p5);
        Serial.print("\t");
        Serial.print("MassConcentrationPm4p0:");
        Serial.print(massConcentrationPm4p0);
        Serial.print("\t");
        Serial.print("MassConcentrationPm10p0:");
        Serial.print(massConcentrationPm10p0);
        Serial.print("\t");
        Serial.print("AmbientHumidity:");
        if (isnan(ambientHumidity)) {
            Serial.print("n/a");
        } else {
            Serial.print(ambientHumidity);
        }
        Serial.print("\t");
        Serial.print("AmbientTemperature:");
        if (isnan(ambientTemperature)) {
            Serial.print("n/a");
        } else {
            Serial.print(ambientTemperature);
        }
        Serial.print("\t");
        Serial.print("VocIndex:");
        if (isnan(vocIndex)) {
            Serial.print("n/a");
        } else {
            Serial.print(vocIndex);
        }
        Serial.print("\t");
        Serial.print("NoxIndex:");
        if (isnan(noxIndex)) {
            Serial.println("n/a");
        } else {
            Serial.println(noxIndex);
        }
    }
}

void readINA226SensorData(){
  Serial.print("INA226\n");

  Serial.println("\n#\tBUS\tSHUNT\tCURRENT\tPOWER");

  panelCurrentControl = controlPanel.getCurrent_mA();
  panelCurrentTest = testPanel.getCurrent_mA();
  inachargeControlCurrentControl = controlChargeController.getCurrent_mA();
  inachargeControlCurrentTest = testChargeController.getCurrent_mA();
  inapanelVoltageControl = controlPanel.getBusVoltage();
  inapanelVoltageTest = testPanel.getBusVoltage();
  inachargeControlVoltageControl = controlChargeController.getBusVoltage();
  inachargeControlVoltageTest = testChargeController.getBusVoltage();
  panelPowerControl = controlPanel.getPower_mW();
  panelPowerTest = testPanel.getPower_mW();
  inachargeControlPowerControl = controlChargeController.getPower_mW();
  inachargeControlPowerTest = testChargeController.getPower_mW();



    Serial.print("CP");
    Serial.print("\t");
    Serial.print(inapanelVoltageControl, 3);
    Serial.print("\t");
    Serial.print(controlPanel.getShuntVoltage_mV(), 3);
    Serial.print("\t");
    Serial.print(panelCurrentControl, 3);
    Serial.print("\t");
    Serial.print(panelPowerControl, 3);
    Serial.println();
    
    Serial.print("CC");
    Serial.print("\t");
    Serial.print(inachargeControlVoltageControl, 3);
    Serial.print("\t");
    Serial.print(controlChargeController.getShuntVoltage_mV(), 3);
    Serial.print("\t");
    Serial.print(inachargeControlCurrentControl, 3);
    Serial.print("\t");
    Serial.print(inachargeControlPowerControl, 3);
    Serial.println();

    Serial.print("TP");
    Serial.print("\t");
    Serial.print(inapanelVoltageTest, 3);
    Serial.print("\t");
    Serial.print(testPanel.getShuntVoltage_mV(), 3);
    Serial.print("\t");
    Serial.print(panelCurrentTest, 3);
    Serial.print("\t");
    Serial.print(panelPowerTest, 3);
    Serial.println();

    Serial.print("TC");
    Serial.print("\t");
    Serial.print(inachargeControlVoltageTest , 3);
    Serial.print("\t");
    Serial.print(testChargeController.getShuntVoltage_mV(), 3);
    Serial.print("\t");
    Serial.print(inachargeControlCurrentTest, 3);
    Serial.print("\t");
    Serial.print(inachargeControlPowerTest, 3);
    Serial.println();


  efficiencyControl = (inachargeControlPowerControl/panelPowerControl)*100;
  efficiencyTest = (inachargeControlPowerTest/panelPowerTest)*100;

  Serial.println(efficiencyControl);
  Serial.println(efficiencyTest);
}



void readModbusAndCompute() {
  uint8_t result;

  // ================== Test Setup (Slave 1) ==================
  RS485.end(); // Stop Serial communication
  delay(10);
  RS485.begin(9600, SERIAL_8N1, RS485_RX_SLAVE_1, RS485_TX_SLAVE_1); // Initialize pins for Slave 1
  node.begin(1, RS485); // Set Slave ID to 1
  delay(10);

  // Read Panel Voltage
  result = node.readHoldingRegisters(PANEL_VOLTAGE, 1);
  panelVoltageTest = ((result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0);

  // Read Charging Current
  result = node.readHoldingRegisters(CHARGING_CURRENT, 1);
  chargeControlCurrentTest = 1000*((result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 100.0 : 0.0);

  // Read Battery Voltage
  result = node.readHoldingRegisters(BATTERY_VOLTAGE, 1);
  chargeControlVoltageTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0;

  // Read Battery Charge Percent
  result = node.readHoldingRegisters(BATTERY_CHARGE_PERCENT, 1);
  batteryChargePercentTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

  // Read Battery Power
  result = node.readHoldingRegisters(BATTERY_POWER, 1);
  batteryPowerTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

  // Read Load Voltage
  result = node.readHoldingRegisters(LOAD_VOLTAGE, 1);
  loadVoltageTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0;

  // Read Load Current
  result = node.readHoldingRegisters(LOAD_CURRENT, 1);
  loadCurrentTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 100.0 : 0.0;

  // Read Load Power
  result = node.readHoldingRegisters(LOAD_POWER, 1);
  loadPowerTest = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

    // Compute Power (Post MPPT)
  chargeControlPowerTest = (chargeControlVoltageTest * chargeControlCurrentTest);
  calcIndexTest = (chargeControlPowerTest/(batteryPowerTest*1000));
  instIndexTest = (chargeControlPowerTest/inachargeControlPowerTest);

  // ================== Control Setup (Slave 2) ==================
  RS485.end(); // Stop Serial communication
  delay(600);
  RS485.begin(9600, SERIAL_8N1, RS485_RX_SLAVE_2, RS485_TX_SLAVE_2); // Initialize pins for Slave 2
  node.begin(2, RS485); // Set Slave ID to 2
  delay(10);

  // Read Panel Voltage
  result = node.readHoldingRegisters(PANEL_VOLTAGE, 1);
  panelVoltageControl = ((result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0);

  // Read Charging Current
  result = node.readHoldingRegisters(CHARGING_CURRENT, 1);
  chargeControlCurrentControl = 1000*((result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 100.0 : 0.0);

  // Read Battery Voltage
  result = node.readHoldingRegisters(BATTERY_VOLTAGE, 1);
  chargeControlVoltageControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0;

  // Read Battery Charge Percent
  result = node.readHoldingRegisters(BATTERY_CHARGE_PERCENT, 1);
  batteryChargePercentControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

  // Read Battery Power
  result = node.readHoldingRegisters(BATTERY_POWER, 1);
  batteryPowerControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

  // Read Load Voltage
  result = node.readHoldingRegisters(LOAD_VOLTAGE, 1);
  loadVoltageControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 10.0 : 0.0;

  // Read Load Current
  result = node.readHoldingRegisters(LOAD_CURRENT, 1);
  loadCurrentControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) / 100.0 : 0.0;

  // Read Load Power
  result = node.readHoldingRegisters(LOAD_POWER, 1);
  loadPowerControl = (result == node.ku8MBSuccess) ? node.getResponseBuffer(0) : 0.0;

    // Compute Power (Post MPPT)
  chargeControlPowerControl = (chargeControlVoltageControl * chargeControlCurrentControl);
  calcIndexControl = (chargeControlPowerControl/(batteryPowerControl*1000));
  instIndexControl = (chargeControlPowerControl/inachargeControlPowerControl);

  // ================== Print Results ==================
  Serial.println("\n===========================");
  Serial.println("Test Setup Data:");
  Serial.print("Panel Voltage (Test): "); Serial.print(panelVoltageTest, 2); Serial.println(" V");
  Serial.print("Charging Current (Test): "); Serial.print(chargeControlCurrentTest, 2); Serial.println(" mA");
  Serial.print("Computed Charging Power (Test): "); Serial.print(chargeControlPowerTest, 2); Serial.println(" mW");
  Serial.print("Battery Voltage (Test): "); Serial.print(chargeControlVoltageTest, 2); Serial.println(" V");
  Serial.print("Battery Charge Percent (Test): "); Serial.print(batteryChargePercentTest, 2); Serial.println(" %");
  Serial.print("Battery Power (Test): "); Serial.print(batteryPowerTest, 2); Serial.println(" W");
  Serial.print("Load Voltage (Test): "); Serial.print(loadVoltageTest, 2); Serial.println(" V");
  Serial.print("Load Current (Test): "); Serial.print(loadCurrentTest, 2); Serial.println(" A");
  Serial.print("Load Power (Test): "); Serial.print(loadPowerTest, 2); Serial.println(" W");
  Serial.print("Calculation Index (Test): "); Serial.print(calcIndexTest, 2); Serial.println("Units");
  Serial.print("Instrument Index (Test): "); Serial.print(instIndexTest, 2); Serial.println("Units");

  Serial.println("\nControl Setup Data:");
  Serial.print("Panel Voltage (Control): "); Serial.print(panelVoltageControl, 2); Serial.println(" V");
  Serial.print("Charging Current (Control): "); Serial.print(chargeControlCurrentControl, 2); Serial.println(" mA");
  Serial.print("Computed Charging Power (Control): "); Serial.print(chargeControlPowerControl, 2); Serial.println(" mW");
  Serial.print("Battery Voltage (Control): "); Serial.print(chargeControlVoltageControl, 2); Serial.println(" V");
  Serial.print("Battery Charge Percent (Control): "); Serial.print(batteryChargePercentControl, 2); Serial.println(" %");
  Serial.print("Battery Power (Control): "); Serial.print(batteryPowerControl, 2); Serial.println(" W");
  Serial.print("Load Voltage (Control): "); Serial.print(loadVoltageControl, 2); Serial.println(" V");
  Serial.print("Load Current (Control): "); Serial.print(loadCurrentControl, 2); Serial.println(" A");
  Serial.print("Load Power (Control): "); Serial.print(loadPowerControl, 2); Serial.println(" W");
  Serial.print("Calculation Index (Control): "); Serial.print(calcIndexControl, 2); Serial.println("Units");
  Serial.print("Instrument Index (Control): "); Serial.print(instIndexControl, 2); Serial.println("Units");
  Serial.println("===========================");
}




// ==== Datalogger ====//
void readFromDatalogger() {
  if (DataSerial.available()) {
    String line = DataSerial.readStringUntil('\n');
    line.trim(); // remove CR/LF whitespace

    if (line.length() > 0) {
      Serial.println("Raw Line: " + line);

      // Expected format: "<irradiance>,YYYY/MM/DD hh:mm:ss"
      int commaIndex = line.indexOf(',');
      if (commaIndex > 0) {
        String irrStr = line.substring(0, commaIndex);
        String timeStr = line.substring(commaIndex + 1);

        irradiance = irrStr.toFloat();
        irradianceTimestamp = timeStr;

        Serial.print("Parsed Irradiance (W/m²): ");
        Serial.println(irradiance);
        Serial.print("Timestamp: ");
        Serial.println(irradianceTimestamp);
        Serial.println("-------------------------------");
      } else {
        Serial.println("Unexpected format received on UART");
      }
    }
  }
}


void readSHT35Sensor(){
  if (sht.readSample()) {

      shtHumidity = sht.getHumidity();
      shtTemperature = sht.getTemperature();
      Serial.print("SHT35\n");
      Serial.print("SHT:\n");
      Serial.print("  RH: ");
      Serial.print(shtHumidity, 2);
      Serial.print("\n");
      Serial.print("  T:  ");
      Serial.print(shtTemperature, 2);
      Serial.print("\n");
  } else {
      Serial.print("Error in readSample()\n");
  }
}

// Initialize SD card with retry
void setupSDCard() {

  hspi.begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS); // SCLK, MISO, MOSI, SS

  const int retries = 3;
  const int delayMs = 200;
  bool mounted = false;

  for (int i = 0; i < retries; i++) {
    if (SD.begin(HSPI_SS, hspi)) {
      mounted = true;
      break;
    } else {
      Serial.println("SD mount failed, retrying...");
      delay(delayMs);
    }
  }

  if (!mounted) {
    Serial.println("Card Mount Failed after retries");
    return;
  }

  uint8_t cardType = SD.cardType();
  if (cardType == CARD_NONE) {
    Serial.println("No SD card attached");
    return;
  }

  Serial.print("SD Card Type: ");
  if (cardType == CARD_MMC) {
    Serial.println("MMC");
  } else if (cardType == CARD_SD) {
    Serial.println("SDSC");
  } else if (cardType == CARD_SDHC) {
    Serial.println("SDHC");
  } else {
    Serial.println("UNKNOWN");
  }

  uint64_t cardSize = SD.cardSize() / (1024 * 1024);
  Serial.printf("SD Card Size: %lluMB\n", cardSize);
}




// Self-healing SD card check
// =======================================================
bool checkSD(bool verbose) {
  // Quick test: try opening a test file
  File file = SD.open("/.check", FILE_WRITE);
  if (file) {
    file.println("ping");
    file.close();
    if (verbose) Serial.println("SD check passed");
    return true;
  }

  // If we got here, the SD failed — attempt recovery
  if (verbose) Serial.println("SD access failed, remounting...");

  SD.end();       // force release
  delay(200);

  if (!SD.begin(HSPI_SS, hspi)) {
    if (verbose) Serial.println("SD re-mount failed");
    return false;
  }

  if (verbose) {
    Serial.println("SD re-mounted successfully");
    uint64_t cardSize = SD.cardSize() / (1024 * 1024);
    Serial.printf("SD Size: %llu MB\n", cardSize);
  }
  return true;
}

// Write to the SD card
void writeFile(fs::FS &fs, const char * path, const char * message){
  if (!checkSD()) return;   // ensure SD is mounted

  Serial.printf("Writing file: %s\n", path);
  File file = fs.open(path, FILE_WRITE);

  if(!file) {
    Serial.println("Failed to open file for writing, retrying...");
    if (!checkSD()) return;    // try remount once more
    file = fs.open(path, FILE_WRITE);
    if(!file) {
      Serial.println("Write retry failed");
      return;
    }
  }

  if(file.print(message)) {
    Serial.println("File written");
  } else {
    Serial.println("Write failed");
  }
  file.close();
}




// Append data to the SD card
void appendFile(fs::FS &fs, const char * path, const char * message) {
  if (!checkSD()) return;   // ensure SD is mounted

  Serial.printf("Appending to file: %s\n", path);
  File file = fs.open(path, FILE_APPEND);

  if(!file) {
    Serial.println("Failed to open file for appending, retrying...");
    if (!checkSD()) return;   // try remount once more
    file = fs.open(path, FILE_APPEND);
    if(!file) {
      Serial.println("Append retry failed");
      return;
    }
  }

  if(file.print(message)) {
    Serial.println("Message appended");
  } else {
    Serial.println("Append failed");
  }
  file.close();
}



String readFile(fs::FS &fs, const char * path){
  if (!checkSD()) return String();  // ensure SD is mounted

  String fileData = "";
  Serial.printf("Reading file: %s\n", path);

  File file = fs.open(path);
  if(!file){
      Serial.println("Failed to open file for reading, retrying...");
      if (!checkSD()) return String();  // try remount once more
      file = fs.open(path);
      if(!file) {
        Serial.println("Read retry failed");
        return String();
      }
  }

  while(file.available()){
      fileData = file.readStringUntil('\n');
      break;
  }
  file.close();
  return fileData;
}



void dischargeLoads(float testBatteryChargePercent, float controlBatteryChargePercent) {
  // Keep track of consecutive readings above threshold
  static int testBatteryChargeCounter = 0;
  static int controlBatteryChargeCounter = 0;

  // 75% threshold for turning on the load
  const float batteryThresholdPercent = 90.0;

  // Check the Test battery charge percent
  if (testBatteryChargePercent >= batteryThresholdPercent) {
    testBatteryChargeCounter++;
  } else {
    testBatteryChargeCounter = 0;
  }

  // Check the Control battery charge percent
  if (controlBatteryChargePercent >= batteryThresholdPercent) {
    controlBatteryChargeCounter++;
  } else {
    controlBatteryChargeCounter = 0;
  }

  // If the Test battery stayed above threshold for at least 3 consecutive reads, turn relay ON
  if (testBatteryChargeCounter >= 3) {
    testLoadRelayStatus("ON");
  } else {
    testLoadRelayStatus("OFF");
  }

  // If the Control battery stayed above threshold for at least 5 consecutive reads, turn relay ON
  if (controlBatteryChargeCounter >= 3) {
    controlLoadRelayStatus("ON");
  } else {
    controlLoadRelayStatus("OFF");
  }
}


//OLED FUNCTION
void logToOLED(String msg) {
  // break message into lines
  int start = 0;
  while (start < msg.length()) {
    int end = start + OLED_LINE_CHARS;
    if (end > msg.length()) end = msg.length();
    String line = msg.substring(start, end);

    // shift buffer up
    for (int i = 0; i < MAX_LINES - 1; i++) {
      logBuffer[i] = logBuffer[i + 1];
    }
    logBuffer[MAX_LINES - 1] = line;

    // draw
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SH110X_WHITE);
    int y = 0;
    for (int i = 0; i < MAX_LINES; i++) {
      if (logBuffer[i].length() > 0) {
        display.setCursor(0, y);
        display.println(logBuffer[i]);
      }
      y += 10; // vertical spacing
    }
    display.display();

    // serial output for each line too
    //Serial.println(line);

    start = end; // move to next chunk
  }
}





void turnOffNetlight()
{
  Serial.println("Turning off SIM800 Red LED...");
  modem.sendAT("+CNETLIGHT=0");
}

void turnOnNetlight()
{
  Serial.println("Turning on SIM800 Red LED...");
  modem.sendAT("+CNETLIGHT=1");
}



